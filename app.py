# app.py
import matplotlib
from flask import Flask, request, jsonify, render_template, send_from_directory, session
import matplotlib.pyplot as plt
import os
import io
import csv
import tempfile
from src.optimization import *
from src.utils import csv2coords  # Use the new utils module
from src.basic_functions import *
import json

app = Flask(__name__, template_folder='templates',
            static_folder='static')
app.secret_key = 'supersecretkey'  # Required for session management

# Use Agg backend for Matplotlib
matplotlib.use('Agg')

STATIC_DIR = os.path.join(os.path.dirname(
    os.path.abspath(__file__)), 'static')
DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
JSON_FILE_PATH = os.path.join(DATA_DIR, 'polygons.json')
SHAPE_FILE_PATH = os.path.join(DATA_DIR, "best_path.shp")
PROJECTED_COORDS_JSON_PATH = os.path.join(
    DATA_DIR, 'projected_coordinates.json')

# Ensure the data directory exists
os.makedirs(DATA_DIR, exist_ok=True)


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/optimize', methods=['POST'])
def optimize():
    debug_info = []
    debug_info.append("Received a request to /optimize")

    # Use the JSON file generated by mapHandler.py
    if os.path.exists(JSON_FILE_PATH):
        file_path = JSON_FILE_PATH
        debug_info.append(f"Using generated JSON file: {file_path}")
    else:
        debug_info.append("No generated JSON file found")
        return jsonify({'error': 'No generated JSON file found', 'debug': debug_info})

    disp_diam = request.form.get('dispDiam')
    if not disp_diam:
        debug_info.append("Display diameter is required")
        return jsonify({'error': 'Display diameter is required', 'debug': debug_info})

    disp_diam = int(disp_diam)
    debug_info.append(f"Display diameter received: {disp_diam}")

    # Extract coords from the uploaded JSON file
    with open(file_path, 'r') as json_file:
        coordinate_info = json.load(json_file)

    all_projected_coords = []
    bestPathList = []

    # Iterate through each polygon in the coordinate info
    for polygon in coordinate_info:
        debug_info.append(f"Extracted coordinates from JSON: {polygon}")

        # Construct the best path and measure runtime
        optimal_func = airtime_coverage_weighted(75, 15, 10)
        pathlist, pathlistruntime = construct_pathlist(
            polygon, disp_diam, children=None, poly_offset=0, num_path=10)  # calculates the optimized path
        datatable, best_path = find_best_path(pathlist, optimal_func)
        debug_info.append(f"Constructed best path: {best_path}")

        # Assuming best_path.to_coordinates() returns coordinates in EPSG:3857
        bestPathList.append(best_path.path)
        projected_coords = best_path.to_coordinates()
        all_projected_coords.append(projected_coords)

        # Save the plot to a file in the static directory
        plot_filename = f'best_path_{time.time()}.png'
        plot_path = os.path.join(STATIC_DIR, plot_filename)
        plt.figure(figsize=(16, 8))
        showpath(best_path)
        plt.savefig(plot_path)
        plt.close()
        debug_info.append(f"Saved plot to {plot_path}")

        # Shapefile extraction

        gdf = gpd.GeoDataFrame(geometry=bestPathList[0])
        gdf.set_crs(epsg=3857, inplace=True)
        gdf.to_file(SHAPE_FILE_PATH)

    # Save projected coordinates to a new JSON file
    try:
        with open(PROJECTED_COORDS_JSON_PATH, 'w') as jsonfile:
            json.dump(all_projected_coords, jsonfile)
            debug_info.append(
                f"Saved projected coordinates to {PROJECTED_COORDS_JSON_PATH}")
    except Exception as e:
        debug_info.append(f"Error saving projected coordinates: {str(e)}")

    return jsonify({
        'result': 'Optimized path calculated. Check the plot.',
        'best_path_coords': all_projected_coords,
        'debug': debug_info
    })


@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory(STATIC_DIR, filename)


def generate_polygons(data):
    polyList = shp2coords(data)
    print(polyList)
    return json.dumps(polyList), polyList


@app.route('/upload', methods=['POST'])
def upload_file():
    if 'files' not in request.files:
        return jsonify(success=False, error="No files part")

    files = request.files.getlist('files')
    if not files or len(files) < 3:
        return jsonify(success=False, error="At least three shapefile components (.shp, .shx, .dbf) are required")

    temp_dir = tempfile.mkdtemp()

    try:
        # Upload the files into temp directory and store path to .shp file
        for file in files:
            file_path = os.path.join(temp_dir, file.filename)
            # Ensure the directory exists
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            file.save(file_path)

        shp_path = [os.path.join(temp_dir, f.filename)
                    for f in files if f.filename.endswith('.shp')][0]

        # Try extracting the polygons as a list and a string, write to json file
        try:
            polygonString, polygonList = generate_polygons(shp_path)

        except Exception as e:
            return jsonify(success=False, error=f"Error reading shapefile: {str(e)}")

        with open(os.path.join(os.path.dirname(__file__), 'data', 'polygons.json'), 'w') as f:
            f.write(polygonString)
        return jsonify(success=True)

    except Exception as e:
        return jsonify(success=False, error=f"Unexpected error: {str(e)}")


@app.route('/data/polygons.json')
def get_polygons():
    return send_from_directory(os.path.join(os.path.dirname(__file__), '..', 'data'), 'polygons.json')


# @app.route('/store-coords', methods=['POST'])
# def store_coords():
#     try:
#         data = request.get_json()
#         print(f"Received data: {data}")

#         x = data['x']
#         y = data['y']

#         with open(CSV_FILE_PATH, 'a', newline='') as csvfile:
#             fieldnames = ['x', 'y']
#             writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

#             csvfile.seek(0, 2)
#             if csvfile.tell() == 0:  # Check if file is empty and write header if it is
#                 writer.writeheader()

#             writer.writerow({'x': x, 'y': y})
#             print(f"Written to CSV: {data}")

#         return jsonify({'status': 'success'})
#     except Exception as e:
#         print(f"Error: {str(e)}")
#         return jsonify({'status': 'error', 'message': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
