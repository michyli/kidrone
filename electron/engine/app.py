# src/app.py
import matplotlib
from flask import Flask, request, jsonify, render_template, send_from_directory, session
import matplotlib.pyplot as plt
import os
import io
import csv
from src.optimization import construct_best_path, showpath
from src.utils import csv2coords  # Use the new utils module
from src.basic_functions import *
import json

app = Flask(__name__, template_folder='templates',
            static_folder='static')
app.secret_key = 'supersecretkey'  # Required for session management

# Use Agg backend for Matplotlib
matplotlib.use('Agg')

STATIC_DIR = os.path.join(os.path.dirname(
    os.path.abspath(__file__)), 'static')
DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
CSV_FILE_PATH = os.path.join(DATA_DIR, 'coordinates.csv')
PROJECTED_COORDS_CSV_PATH = os.path.join(DATA_DIR, 'projected_coordinates.csv')

# Ensure the data directory exists
os.makedirs(DATA_DIR, exist_ok=True)


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/optimize', methods=['POST'])
def optimize():
    debug_info = []
    debug_info.append("Received a request to /optimize")

    # Use the CSV file generated by mapHandler.py
    if os.path.exists(CSV_FILE_PATH):
        file_path = CSV_FILE_PATH
        debug_info.append(f"Using generated CSV file: {file_path}")
    else:
        debug_info.append("No generated CSV file found")
        return jsonify({'error': 'No generated CSV file found', 'debug': debug_info})

    disp_diam = request.form.get('dispDiam')
    if not disp_diam:
        debug_info.append("Display diameter is required")
        return jsonify({'error': 'Display diameter is required', 'debug': debug_info})

    disp_diam = int(disp_diam)
    debug_info.append(f"Display diameter received: {disp_diam}")

    # Extract coords from the uploaded CSV file
    points = csv2coords(file_path)
    debug_info.append(f"Extracted coordinates from CSV: {points}")

    # Construct the best path and measure runtime
    best_path, runtime = construct_best_path(points, disp_diam)
    debug_info.append(f"Constructed best path: {best_path}")
    debug_info.append(
        f"Runtime for constructing the best path: {runtime:.2f} seconds")

    # Save the plot to a file in the static directory
    plot_filename = 'best_path.png'
    plot_path = os.path.join(STATIC_DIR, plot_filename)
    plt.figure(figsize=(16, 8))
    showpath(best_path)
    plt.savefig(plot_path)
    plt.close()
    debug_info.append(f"Saved plot to {plot_path}")

    # Assuming best_path.to_coordinates() returns coordinates in EPSG:3857
    projected_coords = best_path.to_coordinates()

    # Save projected coordinates to a new CSV file
    try:
        with open(PROJECTED_COORDS_CSV_PATH, 'w', newline='') as csvfile:
            fieldnames = ['start_x', 'start_y', 'end_x', 'end_y']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            writer.writeheader()
            for segment in projected_coords:
                writer.writerow({
                    'start_x': segment['start']['x'],
                    'start_y': segment['start']['y'],
                    'end_x': segment['end']['x'],
                    'end_y': segment['end']['y']
                })
            debug_info.append(
                f"Saved projected coordinates to {PROJECTED_COORDS_CSV_PATH}")
    except Exception as e:
        debug_info.append(f"Error saving projected coordinates: {str(e)}")

    return jsonify({
        'result': 'Optimized path calculated. Check the plot.',
        'plot_path': plot_filename,
        'runtime': runtime,
        'best_path_coords': projected_coords,
        'debug': debug_info
    })


@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory(STATIC_DIR, filename)


@app.route('/store-coords', methods=['POST'])
def store_coords():
    try:
        data = request.get_json()
        print(f"Received data: {data}")

        x = data['x']
        y = data['y']

        with open(CSV_FILE_PATH, 'a', newline='') as csvfile:
            fieldnames = ['x', 'y']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            csvfile.seek(0, 2)
            if csvfile.tell() == 0:  # Check if file is empty and write header if it is
                writer.writeheader()

            writer.writerow({'x': x, 'y': y})
            print(f"Written to CSV: {data}")

        return jsonify({'status': 'success'})
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


if __name__ == '__main__':
    app.run(debug=True)
